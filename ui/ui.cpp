//
// Created by Rares Bozga on 28.03.2023.
//

#include "ui.h"
#include <iostream>
#include <vector>

ui::ui() {
    this->graph = Graph();
}

void ui::print_all_commands() {
    std::cout << std::endl << "Graphs" << std::endl;
    std::cout << "read (filename) - Stores in memory the graph from a saved file (as generated by 'write' command)"
    << std::endl;
    std::cout << "write (filename) - Writes graph to a file (CAREFUL: will overwrite the file!)" << std::endl;
    std::cout << "random (vertices) (edges) - Randomize a graph. (NOTE: might take a while)" << std::endl;
    std::cout << "modify addV/remV (index) || addE (from) (to) (cost) || remE (from) (to) - Modifies graph."
    << std::endl;
    std::cout << "peek isV (index) || isE (from) (to) || costOf (from) (to) - Peeks (safely) into graph data."
    << std::endl;
    std::cout << "print - Print the entire parsed graph (NOTE: might take a while)" << std::endl << std::endl;
    std::cout << "exit - See you later!" << std::endl;
}

void ui::parse_args(const std::string& raw_command, std::string *into_where) {
    int index = 0;

    std::string delimiter = " ";
    unsigned long start, end = -1 * delimiter.size();
    do {
        start = end + delimiter.size();
        end = raw_command.find(delimiter, start);
        std::string token = raw_command.substr(start, end - start);
        if (token.length() > 0) into_where[index++] = token;
    } while (end != -1);
}

// COMMAND IMPLEMENTATION

std::string ui::read_command(std::string *args) {
    const clock_t begin_time = clock(); // track time
    if (graph.fromFile(args[1])) {
        float end_time = float(clock() - begin_time) /  CLOCKS_PER_SEC;
        return "Successfully opened file in " + std::to_string(end_time) + "s.";
    } else {
        return "Failed to open file. Did you specify a valid file?";
    }
}

std::string ui::write_command(std::string *args) {
    if (graph.toFile(args[1])) {
        return "Successfully wrote to file.";
    } else {
        return "Failed to write to file. Is this file protected?";
    }
}

std::string ui::random_command(std::string *args) {
    int n = stoi(args[1]);
    int m = stoi(args[2]);

    for (int i = 0; i < n; i++) graph.addVertex(i);

    unsigned long max_possible = n * n;

    int edges = 0;
    while (edges < m && edges < max_possible) {
        int from = (int) (random() % n);
        int to = (int) (random() % n);
        int cost = (int) (random() % 1001);
        if (!graph.isEdge(from, to)) {
            graph.addEdge(from, to, cost);
            edges++;
        }
    }

    if (edges < m) std::cout << "WARN: Could not fit " << m << " edges in a graph with " << n << " vertices!"
    << std::endl;
    return "Generated random graph.";
}


std::string ui::modify_command(std::string *args) {
    if (args[1] == "addV") {
        int v = stoi(args[2]);
        if (graph.addVertex(v)) {
            return "Added vertex!";
        } else {
            return "This vertex already exists!";
        }
    } else if (args[1] == "remV") {
        int v = stoi(args[2]);
        if (graph.removeVertex(v)) {
            return "Removed vertex!";
        } else {
            return "This vertex does not yet exist!";
        }
    } else if (args[1] == "addE") {
        int from = stoi(args[2]);
        int to = stoi(args[3]);
        int cost = stoi(args[4]);
        if (graph.addEdge(from, to, cost)) {
            return "Added edge successfully!";
        } else {
            return "This edge already exists!";
        }
    } else if (args[1] == "remE") {
        int from = stoi(args[2]);
        int to = stoi(args[3]);
        if (graph.removeEdge(from, to)) {
            return "Removed edge successfully!";
        } else {
            return "This edge does not yet exist!";
        }
    }
    return "Invalid use. Please try again";
}

std::string ui::peek_command(std::string *args) {
    if (args[1] == "isV") {
        int v = stoi(args[2]);
        return graph.isVertex(v) ? "True" : "False";
    } else if (args[1] == "isE") {
        int from = stoi(args[2]);
        int to = stoi(args[3]);
        return graph.isEdge(from, to) ? "True" : "False";
    } else if (args[1] == "costOf") {
        int from = stoi(args[2]);
        int to = stoi(args[3]);
        return graph.isEdge(from, to) ? "Cost: " + std::to_string(graph.getCost(from, to)) : "Not an edge.";
    }
    return "Invalid use. Please try again";
}

std::string ui::print_command(std::string *args) {
    graph.print();
    return "Done printing graph.";
}

// MENU

void ui::run() {

    while (true) {

        print_all_commands();

        std::string command;
        getline(std::cin, command);

        std::string args[100];
        parse_args(command, args);

        if (args[0] == "read") {
            this->graph = Graph();
            std::cout << read_command(args) << std::endl;
        }
        else if (args[0] == "write") {
            std::cout << write_command(args) << std::endl;
        }
        else if (args[0] == "random") {
            this->graph = Graph();
            std::cout << random_command(args) << std::endl;
        }
        else if (args[0] == "modify") {
            std::cout << modify_command(args) << std::endl;
        }
        else if (args[0] == "peek") {
            std::cout << peek_command(args) << std::endl;
        }
        else if (args[0] == "print") {
            std::cout << print_command(args) << std::endl;
        }
        else if (args[0] == "exit") {
            std::cout << "Goodbye!" << std::endl;
            break;
        }

    }

}
