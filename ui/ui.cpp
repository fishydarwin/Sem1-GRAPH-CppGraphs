//
// Created by Rares Bozga on 28.03.2023.
//

#include "ui.h"
#include "../graphworker/graphtraverser.h"
#include "../graph/undirected/undirectedgraph.h"
#include <iostream>
#include <fstream>
#include <vector>
#include <set>

using namespace std;

ui::ui() {
    this->graph = new Graph();
}

void ui::print_all_commands() {
    // lab 1 -> 3
    cout << endl << "Graphs" << endl;
    cout << "read (filename) [undirected?] - Stores in memory the graph from a saved file "
                 "(as generated by 'write' command). Optionally, load in undirected mode." << endl;
    cout << "write (filename) - Writes graph to a file "
                 "(CAREFUL: will overwrite the file!)" << endl;
    cout << "random (vertices) (edges) - Randomize a graph-> (NOTE: might take a while)" << endl;
    cout << "modify addV/remV (index) || addE (from) (to) (cost) || remE (from) (to) || modE (from) (to) (cost)"
                 "- Modifies graph->"
    << endl;
    cout << "peek isV (index) || isE (from) (to) || costOf (from) (to) || in || out || edgeCost "
                 "|| vIn (to) || vOut (from) || all || degVIn (to) || degVOut (from) - "
                 "Peeks (safely) into graph data."
    << endl;
    cout << "print - Print the entire parsed graph (NOTE: might take a while)" << endl;
    cout << "search (bfs connComps/mtxMul lowCostWalk) - Search for properties in "
                 "a graph using a certain algorithm." << endl;
    cout << endl;

    // lab 4
    cout << "--- LABORATORY 4 - Assignment 2 - Activity Tracker ---" << endl;
    cout << "activityRead (filename) - Reads a list of activities to make a graph and "
            "then stores it in memory." << endl;
    cout << "activityPeek - Simply lists activities (separate from graph) in current memory cache." << endl;
    cout << "activitySort - Sorts the activities using topological sort via predecessor counters." << endl;
    cout << "activitySummary - See earliest and latest activities, total time of project, "
            "and critical tasks." << endl;

    cout << endl;
    cout << "exit - See you later!" << endl;
}

void ui::parse_args(const string& raw_command, string *into_where) {
    int index = 0;

    string delimiter = " ";
    unsigned long start, end = -1 * delimiter.size();
    do {
        start = end + delimiter.size();
        end = raw_command.find(delimiter, start);
        string token = raw_command.substr(start, end - start);
        if (token.length() > 0) into_where[index++] = token;
    } while (end != -1);
}

// COMMAND IMPLEMENTATION

string ui::read_command(string *args) {
    const clock_t begin_time = clock(); // track time
    if (args[2] == "undirected")
        graph = new UndirectedGraph();
    if (graph->fromFile(args[1])) { // load

        float end_time = float(clock() - begin_time) /  CLOCKS_PER_SEC;
        return "Successfully opened file in " + to_string(end_time) + "s.";

    } else {
        return "Failed to open file. Did you specify a valid file?";
    }
}

string ui::write_command(string *args) {
    if (graph->toFile(args[1])) {
        return "Successfully wrote to file.";
    } else {
        return "Failed to write to file. Is this file protected?";
    }
}

string ui::random_command(string *args) {
    int n = stoi(args[1]);
    int m = stoi(args[2]);

    for (int i = 0; i < n; i++) graph->addVertex(i);

    unsigned long max_possible = n * n;

    int edges = 0;
    while (edges < m && edges < max_possible) {
        int from = (int) (random() % n);
        int to = (int) (random() % n);
        int cost = (int) (random() % 1001);
        if (!graph->isEdge(from, to)) {
            graph->addEdge(from, to, cost);
            edges++;
        }
    }

    if (edges < m) cout << "WARN: Could not fit " << m << " edges in a graph with " << n << " vertices!"
    << endl;
    return "Generated random graph->";
}


string ui::modify_command(string *args) {
    if (args[1] == "addV") {
        int v = stoi(args[2]);
        if (graph->addVertex(v)) {
            return "Added vertex!";
        } else {
            return "This vertex already exists!";
        }
    } else if (args[1] == "remV") {
        int v = stoi(args[2]);
        if (graph->removeVertex(v)) {
            return "Removed vertex!";
        } else {
            return "This vertex does not yet exist!";
        }
    } else if (args[1] == "addE") {
        int from = stoi(args[2]);
        int to = stoi(args[3]);
        int cost = stoi(args[4]);
        if (graph->addEdge(from, to, cost)) {
            return "Added edge successfully!";
        } else {
            return "This edge already exists!";
        }
    } else if (args[1] == "remE") {
        int from = stoi(args[2]);
        int to = stoi(args[3]);
        if (graph->removeEdge(from, to)) {
            return "Removed edge successfully!";
        } else {
            return "This edge does not yet exist!";
        }
    } else if (args[1] == "modE") {
        int from = stoi(args[2]);
        int to = stoi(args[3]);
        int cost = stoi(args[4]);
        if (graph->isEdge(from, to)) {
            graph->removeEdge(from, to);
            graph->addEdge(from, to, cost);
            return "Modified edge successfully!";
        } else {
            return "This edge does not yet exist!";
        }
    }
    return "Invalid use. Please try again";
}

string ui::peek_command(string *args) {
    if (args[1] == "isV") {
        int v = stoi(args[2]);
        return graph->isVertex(v) ? "True" : "False";
    } else if (args[1] == "isE") {
        int from = stoi(args[2]);
        int to = stoi(args[3]);
        return graph->isEdge(from, to) ? "True" : "False";
    } else if (args[1] == "costOf") {
        int from = stoi(args[2]);
        int to = stoi(args[3]);
        return graph->isEdge(from, to) ? "Cost: " + to_string(graph->getCost(from, to)) : "Not an edge.";
    } else if (args[1] == "vIn") {
        int to = stoi(args[2]);
        cout << "Inbound of " << to << endl;
        for (int vertex : graph->getVerticesIn(to)) {
            cout << vertex << " -> " << to << " " << graph->getCost(vertex, to) << endl;
        }
        return "Printed inbound data for a vertex.";
    } else if (args[1] == "vOut") {
        int from = stoi(args[2]);
        cout << "Outbound of " << from << endl;
        for (int vertex : graph->getVerticesOut(from)) {
            cout << from << " -> " << vertex << " " << graph->getCost(from, vertex) << endl;
        }
        return "Printed inbound data for a vertex.";
    } else if (args[1] == "in") {
        GraphIterator iter = graph->iterator();
        iter.first();
        while (iter.valid()) {
            int vertex = iter.getCurrent();
            cout << vertex << ": [ ";
            for (int in: graph->getVerticesIn(vertex)) {
                cout << in << " ";
            }
            cout << "] " << endl;
            iter.next();
        }
        return "Printed vertex inbound data.";
    } else if (args[1] == "out") {
        GraphIterator iter = graph->iterator();
        iter.first();
        while (iter.valid()) {
            int vertex = iter.getCurrent();
            cout << vertex << ": [ ";
            for (int out: graph->getVerticesOut(vertex)) {
                cout << out << " ";
            }
            cout << "] " << endl;
            iter.next();
        }
        return "Printed vertex outbound data.";
    } else if (args[1] == "edgeCost") {
        GraphIterator iter = graph->iterator();
        iter.first();
        while (iter.valid()) {
            int vertex = iter.getCurrent();
            for (int out: graph->getVerticesOut(vertex)) {
                cout << "<" << vertex << ", " << out << "> " << graph->getCost(vertex, out);
                cout << endl;
            }
            iter.next();
        }
        return "Printed edge cost data.";
    } else if (args[1] == "all") {
        GraphIterator iter = graph->iterator();
        // in
        cout << "vertexIn:" << endl;
        iter.first();
        while (iter.valid()) {
            int vertex = iter.getCurrent();
            cout << vertex << ": [ ";
            for (int in: graph->getVerticesIn(vertex)) {
                cout << in << " ";
            }
            cout << "] " << endl;
            iter.next();
        }
        // out
        iter.first();
        cout << endl << "vertexOut:" << endl;
        while (iter.valid()) {
            int vertex = iter.getCurrent();
            cout << vertex << ": [ ";
            for (int out: graph->getVerticesOut(vertex)) {
                cout << out << " ";
            }
            cout << "] " << endl;
            iter.next();
        }
        // out
        cout << endl << "edgeCost:" << endl;
        iter.first();
        while (iter.valid()) {
            int vertex = iter.getCurrent();
            for (int out: graph->getVerticesOut(vertex)) {
                cout << "<" << vertex << ", " << out << "> " << graph->getCost(vertex, out);
                cout << endl;
            }
            iter.next();
        }
        return "Printed all data.";
    } else if (args[1] == "degVIn") {
        int to = stoi(args[2]);
        return "Degree In: " + to_string(graph->getVerticesIn(to).size());
    } else if (args[1] == "degVOut") {
        int from = stoi(args[2]);
        return "Degree Out: " + to_string(graph->getVerticesOut(from).size());
    }
    return "Invalid use. Please try again";
}

string ui::print_command() {
    graph->print();
    return "Done printing graph->";
}

string ui::search_command(string *args) {
    string algo = "none";
    if (args[1] == "bfs") algo = "bfs";
    else if (args[1] == "mtxMul") algo = "mtxMul";
    if (algo == "none") return "Unknown algorithm.";

    if (args[2] == "connComps") {
        GraphTraverser graphTraverser = GraphTraverser(*graph);

        bool save = false;
        string saveDir;

        cout << "Save resulting connected components (yes/no)? ";
        string answer;
        getline(cin, answer);
        if (answer == "yes") {
            save = true;
            cout << "Filenames structure to save at (e.g. 'components' => components1.txt etc.): ";
            getline(cin, saveDir);
        }

        if (algo == "bfs") {

            set<int> foundAll = set<int>();

            GraphIterator iter = graph->iterator();
            iter.first();
            int i = 1;
            while (iter.valid()) {
                int vertex = iter.getCurrent();
                if (foundAll.find(vertex) != foundAll.end()) { iter.next(); continue; } // skip found...

                auto found = graphTraverser.breadthFirstSearch(vertex); // grab via bfs
                Graph component; // required for correct storage, actually
                cout << "Component #" << i << " [";
                for (const auto &mapPair : get<1>(found)) {
                    auto who = mapPair.first;
                    foundAll.insert(who); // fast cuz we're printing too!
                    cout << " " << who;

                    // also generate the graph object in memory
                    component.addVertex(who);
                    for (int in : graph->getVerticesIn(who))
                        component.addEdge(in, who, graph->getCost(in, who));
                    for (int out : graph->getVerticesIn(who))
                        component.addEdge(who, out, graph->getCost(who, out));

                }
                cout << " ]" << endl;

                // save if asked
                if (save) component.toFile(saveDir + to_string(i) + ".txt");

                i++;
                iter.next();
            }
            cout << endl;

            return "Printed all connected components.";
        } else {
            return "Unimplemented operation.";
        }
    }
    else if (args[2] == "lowCostWalk") {

        GraphTraverser graphTraverser = GraphTraverser(*graph);

        int x, y;
        cout << "Please enter the start and target vertices:" << endl;
        cin >> x >> y;

        if (algo == "mtxMul") {

            auto result = graphTraverser.allPairsShortestPath(true, x, y);

            if (result.second.empty())
                cout << "No path was found from x = " << x << " to y = " << y << "." << endl;
            else {
                if (result.second[0] == -1) {
                    cout << "There is a negative cycle in this graph; a path could not be found." << endl;
                } else {
                    cout << "Found minimum cost path: " << endl;
                    for (int node : result.second) {
                        cout << node << " ";
                    }
                    cout << endl;
                    cout << "Total cost of path: " << result.first[x][y] << endl;
                }
            }

            cout << endl;
            return "Completed operation.";

        }

    }

    return "Invalid use. Please try again";
}

// LAB 4

string ui::activityRead_command(string *args) {
    const clock_t begin_time = clock(); // track time

    ifstream fin(args[1]);
    if (fin.fail()) return "Failed to open file. Did you specify a valid file?";

    graph = new Graph();
    activities = vector<Activity>();

    string dateTimeFormat = "%d.%m.%Y-%H:%M:%S";
    while (!fin.eof()) { // load file data
        int activityId, activityPreCount;
        fin >> activityId >> activityPreCount;

        vector<int> activityPre = vector<int>();
        for (int i = 0; i < activityPreCount; i++) {
            int x; fin >> x;
            activityPre.push_back(x);
        }

        tm activityStart {};
        fin >> get_time(&activityStart, dateTimeFormat.c_str());

        int durationMinutes; fin >> durationMinutes;

        auto activity = Activity();
        activity.activityId = activityId;
        activity.requiredActivities = activityPre;
        activity.startTime = activityStart;
        activity.durationMinutes = durationMinutes;
        activities.push_back(activity);
    }

    // parse
    for (const auto &activity : activities) {
        if (!graph->isVertex(activity.activityId)) graph->addVertex(activity.activityId);
        for (const auto &pre : activity.requiredActivities) {
            if (!graph->isVertex(pre)) graph->addVertex(pre);
            graph->addEdge(pre, activity.activityId, 0);
        }
    }

    // done
    float end_time = float(clock() - begin_time) /  CLOCKS_PER_SEC;
    return "Successfully opened file in " + to_string(end_time) + "s.";
}

string ui::activityPeek_command(string *args) {
    cout << "Peeking activities... " << endl;
    for (Activity& activity : activities) {
        cout << activity.toString() << endl;
    }
    return "Done.";
}

string ui::activitySort_command(string *args) {
    GraphTraverser graphTraverser = GraphTraverser(*graph);
    vector<int> sorted = graphTraverser.topologicalSortPredecessor();

    if (sorted.empty()) {
        cyclic: return "The graph representing the activities contains a cycle!";
    } else if (sorted[0] == -1) goto cyclic;

    vector<Activity> remadeActivities;
    for (const int &i : sorted) { // O(n^2), best not to worry about it...
        for (Activity &activity : activities) {
            if (activity.activityId == i) {
                remadeActivities.push_back(activity);
                break;
            }
        }
    }
    activities = remadeActivities; // done!

    return "Completed sort!";
}

string ui::activitySummary_command(std::string *args) {

    std::time_t time_now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());

    int totalTime = 0;
    for (Activity &activity : activities) {

        cout << "Activity #" << activity.activityId << " - ";
        if (activity.requiredActivities.empty()) cout << "Has no prerequisites." << endl;
        else {
            cout << "Prerequisites: ";
            for (const int &i : activity.requiredActivities)
                cout << "#" << i << " ";
            cout << endl;
        }

        char bufferC[80];
        strftime(bufferC, sizeof(bufferC), "%d.%m.%Y-%H:%M:%S", &(activity.startTime));
        std::string earlyTimeString(bufferC);
        cout << "Earliest Start Time: " << earlyTimeString << endl;

        // interpret "latest time" as the nearest time to prerequisite
        tm latestTime{};
        double latestTimeRef = 99999999999; // const known magic number
        bool foundSomeTime = false;
        for (Activity &dependentActivity : activities) { // O(n^2), best not to worry about it...
            if (dependentActivity.activityId == activity.activityId) continue;
            auto maybeReqMe = dependentActivity.requiredActivities;
            if (std::find(maybeReqMe.begin(), maybeReqMe.end(), activity.activityId)
                != maybeReqMe.end()) {
                if (!foundSomeTime) {
                    latestTime = dependentActivity.startTime;
                    latestTimeRef = difftime(mktime(&latestTime), mktime(&(activity.startTime)));
                    foundSomeTime = true;
                }
                else {
                    double diffTime = difftime(mktime(&latestTime), mktime(&(activity.startTime)));
                    if (diffTime < latestTimeRef) {
                        latestTime = dependentActivity.startTime;
                        latestTimeRef = diffTime;
                    }
                }
            }
        }
        cout << "Latest Start Time: ";
        if (foundSomeTime) {
            strftime(bufferC, sizeof(bufferC), "%d.%m.%Y-%H:%M:%S", &(latestTime));
            std::string lateTimeString(bufferC);
            cout << lateTimeString;
        } else {
            cout << "None (no activity depends on this)";
        }
        cout << endl;

        if (difftime(mktime(&(activity.startTime)), time_now) < 0) {
            cout << "CRITICAL ACTIVITY! This activity should be worked on!" << endl;
        }
        cout << endl;

        totalTime += activity.durationMinutes;
    }

    cout << "Total duration of project: " << totalTime << " minutes" << endl;
    return "Completed summary analysis.";
}

// MENU

void ui::run() {

    while (true) {

        print_all_commands();

        string command;
        getline(cin, command);

        string args[100];
        parse_args(command, args);

        if (args[0] == "read") {
            this->graph = new Graph();
            cout << read_command(args) << endl;
        }
        else if (args[0] == "write") {
            cout << write_command(args) << endl;
        }
        else if (args[0] == "random") {
            this->graph = new Graph();
            cout << random_command(args) << endl;
        }
        else if (args[0] == "modify") {
            cout << modify_command(args) << endl;
        }
        else if (args[0] == "peek") {
            cout << peek_command(args) << endl;
        }
        else if (args[0] == "print") {
            cout << print_command() << endl;
        }
        else if (args[0] == "search") {
            const clock_t begin_time = clock(); // track time
            cout << search_command(args) << endl;
            float end_time = float(clock() - begin_time) /  CLOCKS_PER_SEC;
            cout << "Operation done in " + to_string(end_time) + "s." << endl;
        }
        // lab 4
        else if (args[0] == "activityRead") {
            cout << activityRead_command(args) << endl;
        }
        else if (args[0] == "activityPeek") {
            cout << activityPeek_command(args) << endl;
        }
        else if (args[0] == "activitySort") {
            cout << activitySort_command(args) << endl;
        }
        else if (args[0] == "activitySummary") {
            cout << activitySummary_command(args) << endl;
        }
        // exit
        else if (args[0] == "exit") {
            cout << "Goodbye!" << endl;
            break;
        }

    }

}
